# UI自动化测试

## 简介

[UI 测试：包含清单和示例的初学者指南 (testim.io)](https://www.testim.io/blog/ui-testing-beginners-guide/)

[UI Testing: A Detailed Guide | BrowserStack](https://www.browserstack.com/guide/ui-testing-guide)

UI自动化测试，即通过模拟手动操作用户UI界面的方式，以代码方式实现自动操作和验证的一种自动化测试手段。在十年前，那时候还是PC web的天下，以Selenium驱动web UI的自动化测试还是主流。五年前，当测试人员逐渐熟悉了Selenium API编写UI自动化用例时，互联网的主战场已经从web端逐渐过渡到了app端。现在，app在UI自动化方面的框架已经比较成熟，例如我们已经使用了三年多的appium，还有诸如uiautomator、espresso、robotium等等。



**UI能解决什么问题？**

 

1、重复性的功能测试及验证

2、避免疲惫操作时的人为测试遗漏

3、通过UI自动化操作获取其他测试数据的能力



在我学习查阅文献的过程中，我发现国内不少文章都将 UI 测试（UI Test）和端到端测试（E2E Test）混为一谈，认为是同一个测试类型。

事实上，UI 测试（UI Test）和端到端测试（E2E Test）是稍有区别的：

> UI 测试（UI Test）只是对于前端的测试，是脱离真实后端环境的，仅仅只是将前端放在真实环境中运行，而后端和数据都应该使用 Mock 的。
>
> 端到端测试（E2E Test）则是将整个应用放到真实的环境中运行，包括数据在内也是需要使用真实的。

就前端而言，UI 测试（UI Test）更贴近于我们的开发流程。在前后端分离的开发模式中，前端开发通常会使用到 Mock 的服务器和数据。因而我们需要在开发基本完成后进行相应的 UI 测试（UI Test）。



1. 开发时重复操作
2. 发布后验证
3. 持续监控

更快的测试速度，带来更高的测试效率。一般而言，运行一遍功能测试都要以小时为单位，有的甚至以天为单位。而自动化测试则一般都在分钟级别，如果运行在分布式环境下，甚至可以降到秒级。由此可见，通过自动化测试，测试人员可以省去大量的手工测试时间，从而有更多时间去熟悉业务和完善测试用例，在提高自身测试效率的同时，也有助于提升整体的软件质量。

更好的稳定性和可扩展性。功能测试靠人，自动化测试靠机器，因此，无论是运行测试的稳定性，还是测试能力的可扩展性（比如从测试1个应用变为测试10个应用），自动化测试都远超功能测试。

回归测试。每一次应用发布，都伴随着一次回归测试。对于重复性的工作，机器显然更适合。

兼容性测试。不管是Web测试，还是App测试，兼容性测试都是必不可少的一环。以Web测试为例，同样的测试用例，需要在不同的浏览器上分别运行一遍，这对测试人员而言不可谓不是一种折磨。

大规模测试。如果一次测试涉及的测试用例过多（比如100+），功能测试难免会有遗漏或者重复，而自动化测试可以轻松确保一个不少，一个也不多。



自动化测试的优点很多，简单罗列几条：避免重复工作、提高测试效率、保证每次测试地一致性和可重复性、更好的利用资源（周未/晚上的资源空闲时段）、节省人力资源、增加软件信任度、缩短软件开发测试周期让产品更快投放市场、提高软件测试的准确度和精确度，添加软件信任度。

并不是任何应用产品都适合做自动化测试，选择自动化测试之前必须确认你的项目符合以下要求：软件需求变动不频繁、产品更新维护周期长、比较频繁的回归测试、自动化测试脚本可重复使用，否则光是准备大量的测试脚本就足以让测试人员崩溃。



#### 1. 验证逻辑而非UI

UI的验证会引入大量的不稳定因素。换句话说，像当年的测试大牛段念说的，你跑过了UI自动化，你就相信没问题了吗？不会相信，原因是啥？因为聪明的你会发现，你验证的东西越多，例如界面的每个按钮，颜色，排布，互联网应用变化最大的就是UI, 你的用例就越不稳定，所以你最终肯定不会验证全部UI。那结果就是"然并卵"了, 你根本不会相信这个用例真的通过了。因此给大家定个UI自动化能做的，验证逻辑（另外一种说法，说这种叫功能自动化）。什么叫验证逻辑？例如验证qq是否登录成功，验证到了好友列表，就是登录成功，甚至有登录成功的日志都可以，怎么稳定怎么行。

#### 2.代替大量的UI重复操作

简单来说就是UI自动化你要投入5元，只是执行4次，每次赚5毛的话，那你还亏3元的问题。什么时候会大量呢？像手Q, 编译百个市场的包，每个包要验证核心功能。或者像性能ui自动化监控，同一个用例为了多次采样，也会执行多次。还有每日构建，集成，都可以。关键点就是用次数来增加价值，UI自动化能帮你确保不出死人的问题，如登录不了，登录了又卡死，或者是监控UI之外的其他，如性能。这些都有机会让其价值高于成本的。

## 有哪些测试类型？

前端测试主要分为 3 种：**单元测试（Unit Test）**、**集成测试（Integration Test）**、**UI 测试（UI Test）**

三种测试的占比分别为：

![测试金字塔](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7391f504a49740a696e03869aac48648~tplv-k3u1fbpfcp-watermark.awebp)

## **Three.js的E2E方案**

### 1. 确定正确期待值: 创建期望正确渲染的截图快照。

- 启动一个静态文件的HTTP服务，加载 Three.js 本地的示例。
- 用无头浏览器(Headless browser) 访问示例，并保存3D正确效果的截图快照。
- 关闭HTTP服务。

![img](https://pic1.zhimg.com/50/v2-6b969b1d8f1db46c0965b0db1576810a_720w.jpg?source=1940ef5c)

### 2. 比对迭代前后差异:

- 启动一个静态文件的HTTP服务，加载 Three.js 本地的示例。
- 用无头浏览器(Headless browser) 访问迭代后的示例，并将原有正确效果的图片做图片像素的差异匹配。如果匹配结果像素差异度大于 0.5% 就是测试用例失败。
- 关闭静态HTTP服务。

![img](https://pic1.zhimg.com/50/v2-7bc758ccc6125a973e22a776f0ae59df_720w.jpg?source=1940ef5c)

### 3. 改进E2E测试，让差异可视化

- 用 jimp 把匹配差异的像素标记给保存成图片，方便查看差异

![img](https://pic1.zhimg.com/50/v2-2cfb61c427fefd3764b40b3b3c4adc01_720w.jpg?source=1940ef5c)

- 第一张图片为预期正确结果。
- 第二张图片加了蓝色的圆环，为错误结果。
- 第三张图片是对比了预期和错误结果后，用红色像素标记出差异点。

修改后的链路流程图大致如下  

![img](https://pic3.zhimg.com/80/v2-e8f33138c88c3c0928640158f6b887cf_720w.jpg?source=1940ef5c)



### 完整的E2E测试链路

![img](https://pic1.zhimg.com/50/v2-f6a305b16578d0270109cb938e123e56_720w.jpg?source=1940ef5c)

## E2E测试

E2E（end to end）测试是一个边界比较模糊的概念，大概有这样几个特征吧：

- 把整个系统当作一个黑盒
- 测试人员模拟真实用户在浏览器中操作UI
- 测试出的问题可能是前端也可能是后端导致的

## 前端E2E

一般来说，我的Unit test是和业务代码同步编写的，调试和开发炒鸡方便。

主要的业务流程可能会写E2E，不过规模要小很多，主要目的是：

- 便于给PM展示业务流程
- 便于修改Bug之后的回归

## 为什么要进行UI自动化测试

业务的更新迭代频繁，传统测试大部分都还是手工、肉眼的模式来进行，无法满足产品敏捷开发、快速迭代的需求。而UI自动化能让全功能的回归变得简单，释放纯手工测试的人力资源，并且回归测试能够覆盖到所有的逻辑场景，这对测试的效率，以及整个开发流程的效率都是很大的提升，并且能够规避很多人的主观和客观因素导致的漏测或者疏忽。

其他测试方式的局限性：

**单元测试（Unit Testing）**

事实上，单元测试确实能够帮助我们发现大部分的问题，但是在复杂的前端交互中，单纯的单元测试并不能真实地反映用户操作的路径，而单元测试一般的场景是测试一系列的功能集合。

**快照测试（Snapshot Testing）**

DOM结构并不能完全反映页面的视觉效果，DOM结构不变并不完全等于样式不变。此外，大多数工具都是React专用，非React应用基本不支持。

*笔者想说：*

> 很多人认为，UI总是频繁的变动，导致测试用例维护成本高，性价比低，因此UI自动化测试比较适合场景稳定的业务。其实不是，这里的UI不仅仅指的是视觉，更多的是业务逻辑。UI可以多变，但业务逻辑一定是趋于稳定的，尤其是核心业务，想一想用户得多辛苦才能适应这种业务逻辑频繁变更的产品啊。

## 哪些项目适合引入自动化测试？

现实中，我们经常会针对一些活动开发一些一次性的代码模块，这样的代码模块功能简单，且后续继续迭代的可能性低，这种代码就完全没有必要引入自动化测试工具。

**适合引入自动化测试的场景：**

1. 公共库类的开发维护
2. 中长期项目的迭代/重构
3. 引用了不可控的第三方依赖

这些场景是需要引入自动化测试来对现有代码进行约束的。**尤其是中长期项目，迭代/重构时人力回归困难，自动化测试就显得尤为重要！**

## 什么样的项目适合自动化测试

性价比：按照测试金字塔模型以及投入/产出比，越向下，回报率越高；

Google的自动化分层投入占比：

- 小测试（Unit）：占比70%；
- 中测试（Service）：占比20%；
- 大测试（UI）：占比10%；

自动化测试面临的挑战：面临的最大挑战就是变化，因为变化会导致测试用例运行失败，所以需要对自动化脚本不断debug，如何控制成本、降低成本是对自动化测试工具以及人员能力的挑战。



![img](https://pic1.zhimg.com/80/v2-684651e3457ecce81212ba1a4f953530_720w.jpg)

### 功能自动化测试的条件：

- 需求相对稳定
- 冒烟测试通过
- 测试周期长

## selenium

Selenium是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE(7、8、9)、Mozilla Firefox、Mozilla Suite等。这个工具的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。支持自动录制动作和自动生成 .Net、Java、Perl等不同语言的测试脚本。Selenium 是ThoughtWorks专门为Web应用程序编写的一个验收测试工具。其升级版本为Webdriver。

- Selenium IDE: 一款Firefox插件，以图形化方式支持录制脚本、自动生成脚本等功能。用于本地开发和调试TC（Test Case）。
- Selenium WebDriver: 通过各浏览器厂商提供的原生Driver，指挥浏览器进行各类页面操作。
- Selenium Grid: 适用于分布式环境下运行大量的TC，Hub根据TC的环境要求分发给各个符合条件的Node执行。使用Selenium Grid可以轻松搭建一个分布式的自动化测试环境，特别适合运行大规模的测试用例和兼容性测试（各个节点运行不同的WebDriver）![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/5/15/7a6f2962d7b9a634d492316d5a8a74ab~tplv-t2oaga2asx-watermark.awebp)

## demo
